(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{499:function(v,_,e){"use strict";e.r(_);var T=e(4),p=Object(T.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("百度百科")]),v._v(" "),e("p",[v._v("超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。Ted Nelson 组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的 RFC，其中著名的 RFC 2616 定义了 HTTP 1.1。")]),v._v(" "),e("p",[v._v("主要特点\n1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。")]),v._v(" "),e("p",[v._v("2、灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。")]),v._v(" "),e("p",[v._v("3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。")]),v._v(" "),e("p",[v._v("4.无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。")]),v._v(" "),e("p",[v._v("5、支持 B/S 及 C/S 模式")]),v._v(" "),e("p",[v._v("HTTP 之请求消息 Request\n客户端发送一个 HTTP 请求到服务器的请求消息包括以下格式：")]),v._v(" "),e("p",[v._v("请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。")]),v._v(" "),e("p",[v._v("head")]),v._v(" "),e("p",[v._v("HTTP 之响应消息 Response\n一般情况下，服务器接收并处理客户端发过来的请求后会返回一个 HTTP 的响应消息。")]),v._v(" "),e("p",[v._v("HTTP 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文")]),v._v(" "),e("p",[v._v("第一部分：状态行，由 HTTP 协议版本号， 状态码， 状态消息 三部分组成。")]),v._v(" "),e("p",[v._v("第一行为状态行，（HTTP/1.1）表明 HTTP 版本为 1.1 版本，状态码为 200，状态消息为（ok）")]),v._v(" "),e("p",[v._v("第二部分：消息报头，用来说明客户端要使用的一些附加信息")]),v._v(" "),e("p",[v._v("第二行和第三行为消息报头，")]),v._v(" "),e("p",[v._v("Date:生成响应的日期和时间；Content-Type:指定了 MIME 类型的 HTML(text/html),编码类型是 UTF-8")]),v._v(" "),e("p",[v._v("第三部分：空行，消息报头后面的空行是必须的")]),v._v(" "),e("p",[v._v("第四部分：响应正文，服务器返回给客户端的文本信息。")]),v._v(" "),e("p",[v._v("HTTP 之状态码\n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:")]),v._v(" "),e("p",[v._v("1xx：指示信息--表示请求已接收，继续处理")]),v._v(" "),e("p",[v._v("2xx：成功--表示请求已被成功接收、理解、接受")]),v._v(" "),e("p",[v._v("3xx：重定向--要完成请求必须进行更进一步的操作")]),v._v(" "),e("p",[v._v("4xx：客户端错误--请求有语法错误或请求无法实现")]),v._v(" "),e("p",[v._v("5xx：服务器端错误--服务器未能实现合法的请求")]),v._v(" "),e("p",[v._v("常见状态码：")]),v._v(" "),e("p",[v._v("200 OK//客户端请求成功")]),v._v(" "),e("p",[v._v("400 Bad Request//客户端请求有语法错误，不能被服务器所理解")]),v._v(" "),e("p",[v._v("401 Unauthorized//请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用")]),v._v(" "),e("p",[v._v("403 Forbidden//服务器收到请求，但是拒绝提供服务")]),v._v(" "),e("p",[v._v("404 Not Found//请求资源不存在，eg：输入了错误的 URL")]),v._v(" "),e("p",[v._v("500 Internal Server Error//服务器发生不可预期的错误")]),v._v(" "),e("p",[v._v("503 Server Unavailable//服务器当前不能处理客户端的请求，一段时间后可能恢复正常")]),v._v(" "),e("p",[v._v("GET 和 POST 请求的区别\n1:GET 提交，请求的数据会附在 URL 之后（就是把数据放置在 HTTP 协议头中），以?分割 URL 和传输数据，多个参数用&连接；")]),v._v(" "),e("p",[v._v("如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密")]),v._v(" "),e("p",[v._v("2:POST 提交：把提交的数据放置在是 HTTP 包的包体中。上文示例中红色字体标明的就是实际的传输数据")]),v._v(" "),e("p",[v._v("因此，GET 提交的数据会在地址栏中显示出来，而 POST 提交，地址栏不会改变")]),v._v(" "),e("p",[v._v("实际开发中传输大小存在的限制主要有：")]),v._v(" "),e("p",[v._v("GET:特定浏览器和服务器对 URL 长度有限制，例如 IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系 统的支持。")]),v._v(" "),e("p",[v._v("因此对于 GET 提交时，传输数据就会受到 URL 长度的 限制。")]),v._v(" "),e("p",[v._v("POST:由于不是通过 URL 传值，理论上数据不受 限。但实际各个 WEB 服务器会规定对 post 提交数据大小进行限制，Apache、IIS6 都有各自的配置。")]),v._v(" "),e("p",[v._v("3、安全性")]),v._v(" "),e("p",[v._v("POST 的安全性要比 GET 的安全性高。比如：通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻击")])])}),[],!1,null,null,null);_.default=p.exports}}]);